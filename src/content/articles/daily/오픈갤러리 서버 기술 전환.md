---
title: 오픈갤러리 서버 기술 전환
description: 기술 전환 여정
category: daily
createdAt: "2021-11-04"
---

## 배경

**_Django FullStack_**으로 서비스를 운영하고 있지만, 서비스의 규모가 커지고(기존 서비스 고도화 및 CC페이지 신설), 스택이 노후화 됨에 따라 기술 전환을 결정하게 됨. 이에따라 기존의 **_Django_**를 **_Django Rest Framework_**를 전환해 API server로 활용하고, Next.js를 사용해 Frontend server를 구축할 예정입니다., 이에 따라AWS에서도 **_Elastic beanstalk_**를 사용하고 있지만 이를 **_Elastic Container Service_**로 전환하고자 합니다.

## 목표

지금 서비스하고 있는 Django FullStack은 점진적으로 **_Django Rest Framework_** 로 전환하여 API서버의 역할을 하게 될 예정. (하지만 현재에는 기존 서비스는 현행을 유지하고, 새로운 프로젝트를 위한 프론트 서버 추가와 신설페이지에 대한 API로만 사용 할듯.)

---

하나의 컨테이너에서 서비스를 모두 관리하는 것을 목표로 한다.

**_Nginx_**에서, 이하의 URL로 접근할 경우 리버스 프록시를 통해 기존 **_Django_**가 돌아가고 있는 api server port로 넘겨줍니다.

/api

**_Nginx_**에서, 이하의 URL로 접근할 경우 리버스 프록시를 통해 기존 **_Next.js_**가 돌아가고 있는 port로 넘겨줍니다.

/

## 기술

> 확정 된 스팩이 아니기에 언제든지 변경될 수 있음

- AWS : Elastic Container Service
- Docker : 이하의 컨테이너를 갖고 있다.
  - Nginx (web server)
  - **기존서비스**
  - Gunicorn (wsgi server)
  - Django (wsgi application)
  - **신규 프론트 서버**
  - Next.js
  - SWR (for data fetch)
  - Recoil (for state management)
  - Sass (Module CSS)
  - 등등..

## 구현

> 우선 local에서 구현해보고 dockerize 해볼 예정입니다.

### Nginx + Gunicorn + Django + Next.js

### Django Project

설정해둔 virtualenv에서 gunicorn을 설치하고 gunicorn --bind 0:5000 config.wsgi:application 를 입력하면 wsgi server가 실행됩니다.

### Next.js Project

create-next-app을 통해 next프로젝트를 생성했습니다. 이를 npm run build 후, npm run start를 통해 node server가 실행됩니다.

### Nginx

이를 Nginx와 연결해보겠습니다.

Nginx를 통해 servers directory에 opengallery 파일 생성.

현재 static 폴더명이 같아서 변경이 필요함.

기존의 django 프로젝트의 static폴더명을 static-django등으로 바꾸고, next.js를 통해 서비스하는 프론트 서버의 static폴더명을 static으로 해주는 것이 낫다고 판단했습니다.

왜냐하면 django 프로젝트는 궁극적으로 api-server의 역할을 하게 될 것이기 때문입니다. 또한 next.js에서 static폴더 명을 변경이 가능한지 리서치해본 결과, next config에서 static 폴더명을 변경해줄 수 없었습니다. 이렇게 되면 다 뜯어봐야할것 같기에 django static폴더 명을 변경하는 것으로 결정했습니다.

/luna /aa /(index) 이 세가지 프로젝트도 개별적인 프로젝트니깐 api서버가 나오면 점진적으로 분리가 가능할 듯 합니다.

위의 명시한 부분을 반영하려면, 우선 django settings에서 STATIC_URL = '/static-django/' 로 바꿔주고, css파일에서 static/pages로 시작하는 코드들을 static-django/pages로 바꾸면 됩니다.

…인줄 알았는데 next.js는 static route가 달라 안 바꿔도 될듯 합니다. 최종적인(1차적인) nginx config는 다음과 같습니다.

```
server {
        listen 3030;
        server_name 127.0.0.1;

        location = /favicon.ico { access_log off; log_not_found off; }


        location /static {
                alias /Users/jade/projects/projectfolder/projectname/static;
        }

	location / {
         	rewrite ^/cc/(.*)$ /$1 break;
		proxy_pass http://localhost:4000;
		proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
		proxy_set_header Host $host;
        }
	location /api/ {
        		proxy_pass http://localhost:5000;
        }

}
```

이 상태라면, local에서의 설정은 끝났다고 해도 무방할 듯 합니다. 이제 dockerize를 해보겠습니다.

#### Docker

여러 개의 컨테이너를 다루게 될 것이기에 Docker Compose를 사용합니다. (도커 컴포즈는 도커 실행 시 복잡한 설정을 쉽게 관리하기 위해 YAML 파일에 정의하는 툴입니다.)

YAML파일 작성방법도 공부해보면 좋을듯 합니다.

**docker-compose.yml**

```docker-compose
version: '3'

services:
# WS
  nginx:
    container_name: nginx
    image: nginx
    restart: unless-stopped
    ports:
      - 3030:3030
    volumes:
      # 호스트 디바이스의 저장소와 컨테이너를 연결하기 위해 volumes를 사용
      - ./nginx:/etc/nginx
      - ./frontend/.next/static:/static-frontend
      - ./backend/projectname/static:/static-backend
    depends_on:
      # 호스트 디바이스의 저장소와 컨테이너를 연결하기 위해 volumes를 사용
      - frontend
      - backend
    command: "/bin/sh -c 'while :; do sleep 6h & wait $${!}; nginx -s reload; done & nginx -g \"daemon off;\"'"

# Next
  frontend:
    container_name: frontend
    build:
      context: ./frontend/
      dockerfile: Dockerfile
    ports:
      - "4000:4000"
    expose:
      - 4000
# Django
  backend:
    container_name: backend
    build:
      context: ./backend/
      dockerfile: Dockerfile
    ports:
      - "5000:5000"
    expose:
      - 5000

```

로컬 또는 외부(docker client라고 칭합니다.)에서 3030 포트로 접근할 경우, docker server의 Nginx가 돌아가고 있는 3030 포트로 포트포워딩을 시켜주고 Nginx에서 request에 맞는 response를 내뱉게 됩니다. 이제 각각의 Dockerfile을 만들어보겠습니다.

#### Nginx

**config file**

```
upstream frontend {
    server frontend:4000;
}

upstream backend {
    server backend:5000;
}

server {
        listen 3030;
        server_name localhost;

        location = /favicon.ico { access_log off; log_not_found off; }

        location /_next/static {
            alias /static-frontend;
        }

	    location /static {
            alias /static-backend;
        }

	    location /cc/ {
         	rewrite ^/cc/(.*)$ /$1 break;
            proxy_pass http://frontend;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header Host $host;
        }
	    location / {
            proxy_pass http://backend;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header Host $host;
        }
}
```

#### Django

**dockerfile**

```dockerfile
# 기본 이미지를 python3.9 로 설정
FROM python:3.9

# 환경 변수 설정
ENV DJANGO_SETTINGS_MODULE config.settings.local
ENV PYTHONUNBUFFERED 1

# COPY: 현재 경로(.)에 존재하는 파일들을 이미지 /opengallery-api 경로에 모두 추가
COPY . /backend
WORKDIR /backend
RUN pip install -r requirements/local.txt

# EXPOSE: 컨테이너 실행 시 노출될 포트
EXPOSE 5000

# CMD: 컨테이너 시작 시 실행되는 명령어로 위 ENTRYPOINT 명령어 뒤 인자로 실행하게 된다.
CMD ["python", "manage.py", "runserver", "0.0.0.0:5000"]
```

#### Next.js

**dockerfile**

```dockerfile
# 기본 이미지를 node:12 로 설정
FROM node:12

# 환경 변수 설정
ENV PORT 4000

# COPY: 현재 경로(.)에 존재하는 파일들을 이미지 /opengallery 경로에 모두 추가
COPY . /frontend
WORKDIR /frontend

# 종속성 설치
COPY package*.json /frontend/
RUN npm install

# EXPOSE: 컨테이너 실행 시 노출될 포트
EXPOSE 4000

# 빌드
RUN npm run build

# CMD: 컨테이너 시작 시 실행되는 명령어로 위 ENTRYPOINT 명령어 뒤 인자로 실행하게 된다.
CMD ["npm", "run", "dev"]
```

해당 docker-compose를 통해 docker-compose up -d --build입력 시 정상적으로 동작하는 것을 확인하였습니다. 하지만 DB를 docker에서 설치해주지 않아 실제 접속은 해보지 못하였습니다. 이에 대한 해결책은 크게 두가지로 생각됩니다.

- docker에서 postgres 이미지를 run하여 local DB를 반영하는 방법.
- docker에서 test-server db 정보를 환경변수로 넘겨주는 방법.

도커로 이전하게 될 경우에는 개발환경의 편의를 위해서 로컬에서 DB를 돌리기 보다는 DB테스트 서버를 활용하는 방안으로 하는게 좋을 것 같다고 생각이 됩니다.

만약 첫번째 방법으로 하게 된다면, postgres container가 하나 더 추가될 것입니다. 그렇지만 production단계에서는 다AWS에서 제공하는 Database를 사용하고 있기에 부적합하다고 여겨집니다.

따라서 두번 째 방법으로 base.py에 environ.Env.read_env(os.path.join(ROOT_DIR, '.env')) 를 넣어줍니다.

django에서는 환경변수가 local의 경우에는 pycharm에 의해 정의되고 있었고, 배포하는 경우에는 또 다른 방식으로 정의하고 있습니다. docker를 두 환경에서 모두 같은 환경에서 사용하기 위해서 .env파일에서 환경변수를 관리합니다.

이로써 docker로 개발환경을 세팅을 마쳤습니다. 며칠간 삽질도 많이 했지만 어찌어찌 되었네요.

## CI/CD

위에서 처음에 언급했던 대로, docker container기반의 개발환경이 갖추어지면 Elastic Container Service를 사용하게 될 것입니다. 이부분은 추후 리서치 해보겠습니다!
